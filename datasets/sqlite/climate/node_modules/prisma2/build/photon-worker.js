const { Photon } = require(process.argv[2])

const photon = new Photon()
let activeDatamodel = null // The datamodel that is currently being queried against

process.on('message', async ({ requestId, action, data }) => {
  let response
  switch (action) {
    case 'connect':
      response = await connect(data)
      break

    case 'get-dmmf':
      response = await getDMMF(data)
      break

    case 'get-typings':
      response = await getTypings(data)
      break

    case 'request':
      response = await request(data)
      break

    case 'disconnect':
      response = await disconnect()
      break
  }

  process.send({ requestId, ...response })
})

const connect = async ({ datamodel, credentials = {}, binaryPath }) => {
  try {
    if (!datamodel) {
      // This would only run in Electron
      datamodel = await photon.introspect(credentials)
    }

    if (activeDatamodel === datamodel) {
      // If the datamodel hasn't changed, there's no reason to restart/recreate photon
      return { error: null }
    }

    activeDatamodel = datamodel

    await photon.stop()
    await photon.start({
      datamodel,
      binaryPath,
    })
    return { error: null }
  } catch (e) {
    return { error: { message: e.message, stack: e.stack }, data: null }
  }
}

const getDMMF = async () => {
  try {
    const dmmf = await photon.getDMMF()
    return { error: null, data: dmmf }
  } catch (e) {
    return { error: { message: e.message, stack: e.stack }, data: null }
  }
}

const getTypings = async () => {
  try {
    const typings = await photon.getTypings()
    return { error: null, data: typings }
  } catch (e) {
    return { error: { message: e.message, stack: e.stack }, data: null }
  }
}

const request = async ({ query }) => {
  try {
    const { error, response, meta } = await photon.request(query)
    return { error, data: { response, meta, error } }
  } catch (e) {
    return { error: { message: e.message, stack: e.stack }, data: null }
  }
}

const disconnect = async () => {
  try {
    await photon.stop()
    return { error: null }
  } catch (e) {
    return { error: { message: e.message, stack: e.stack }, data: null }
  }
}
